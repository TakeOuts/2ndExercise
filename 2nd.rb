# coding: utf-8
#!/usr/bin/env ruby

# Реализовать Ruby скрипт, который будет считывать из указанного 
# текстового файла комбинации в виде 4+6, 8-2, 17*3, -36/9, разделенные 
# переносом строки, т.е. простейшие арифметические действия над целыми 
# числами. Программа должна выполнять указанное действие и на выход 
# выдавать файл с результатами построчно, в соответствии с входным файлом. 
# В случае неверного ввода или какой-либо ошибки в процессе вычисления в 
# файл записывать сообщение об ошибке в соответствующую строку.

# Уточнения:
# 1. Программа отбрасывает выражения, которые содержат 2 операции в подряд: 15/-14.
# 2. Также отбрасываются строки, которые содержат более одной арифметической комбинации.
# 3. Учитываются как положительные числа, стоящие слева, так и отрицательные
# 4. В целях безопастности не используется функция "eval" (возможно ошибочное мнение)
# 5. Все ошибки записываются в общий выходной файл.

# Используется механизм исключени как для работы с файлами, так и для проведения арифметических операций.
begin
  # Открываем файлы для чтения и записи с соответствующими правами.
  in_f = File.open('calc.txt')
  out_f = File.open('calc_out.txt', 'a+')
  
  # Построчно считываем файл и производим анализ
  in_f.each_line do |line|
    # Ищем в текущей строке подстроку, которая удовлетворяет регулярному выражению ниже
    match = line.scan(/(-?\d+)([+\-*\/])(\d+)/)
    # Если найдено только одна подстрока, то производим необходимую операцию
    if match.count == 1
      i, op, j = match[0]
      # Для проведения арифметического действия используется метод #send, передавая ему в качестве аргумента символ, соответствующий имени арифметической операции
      begin
        out_f.write("#{i.to_i.send op, j.to_i}\n")
      rescue ZeroDivisionError # Деление на ноль
        out_f.write("На ноль делить нельзя\n")
      rescue => e # Здесь ловится всё остальное
        out_f.write("Случилось непредвиденное: #{err}\n")
      end
    elsif match.count == 0  
      out_f.write("Совпадений не найдено\n")
    else
      out_f.write("Строка не распознана\n")
    end 
  end
  
rescue IOError
out_f.write("Не удалось записать на диск\n")

rescue SystemCallError
out_f.write("Произошла ошибка системного вызова\n")

rescue => err # Здесь ловится всё остальное (ошибка при считывании)
  # В случае возникновения ошибки записываем всю информацию в файл и выводим на консоль.
  out_f.write("Внешняя ошибка: #{err}\n")
  err
  
ensure # Этот блок выполняется в любом случае
  # Вне зависимости от успешности выполнения "небезопасного" блока, файлы будут закрыты
  in_f.close unless in_f.nil?
  out_f.close unless out_f.nil?
end


# Пример реализации с использованием eval:

#def calc(user_input)
#  result = eval(input_string)
#  puts "Answer: #{result}"
#end
#puts "Enter formula"

#user_input = gets()
# e.g. "1+3*8"

#calc(user_input)