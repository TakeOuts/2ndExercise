# coding: utf-8
#!/usr/bin/env ruby

# Реализовать Ruby скрипт, который будет считывать из указанного 
# текстового файла комбинации в виде 4+6, 8-2, 17*3, -36/9, разделенные 
# переносом строки, т.е. простейшие арифметические действия над целыми 
# числами. Программа должна выполнять указанное действие и на выход 
# выдавать файл с результатами построчно, в соответствии с входным файлом. 
# В случае неверного ввода или какой-либо ошибки в процессе вычисления в 
# файл записывать сообщение об ошибке в соответствующую строку.

# Уточнения:
# 1. Программа отбрасывает выражения, которые содержат 2 операции в подряд: 15/*14.
# 2. При этом, комбинации вида: +15/+15 и -15/-15 разссматриваются как операции с положительно и отрицательно определенными числители и знаменатели.
# 3. Также отбрасываются строки, которые содержат более одной арифметической комбинации: 3+3 3+3. Но выводится соответствующее сообщение.
# 4. В целях безопастности не используется функция "eval" (возможно ошибочное мнение)
# 5. Все ошибки записываются в общий выходной файл.
# 6. Ввод имени входного и выходного файла возможен через аргументы командной строки.
# 7. Если пользователь ошибся при вводе имени файла, то выводится соответствующее сообщение. Вместо этого файла используется дефолтный.
# 8. Выражения, содержащие пробелы между числом и арифметическим действем, так же учитываются: 15 / 12

# Проверки существования аргументов, которые возможно содержат информацию о входном и выходном файле
# Если указано только имя входного файла
if ARGV.count == 1
  inputFileName = ARGV[0] # Входной файл
  outputFileName = "calc_out.txt" # Выходной файл
  puts "Поскольку Вы не ввели информацию о выходном файле, то все будет записано в calc_out.txt"
# Если указан и входной, и выходной файл
elsif ARGV.count == 2
  inputFileName = ARGV[0]
  outputFileName = ARGV[1]
# Не указана информация о входном и выходном файле
else
  inputFileName = "calc.txt"
  outputFileName = "calc_out.txt"
  puts "Поскольку Вы не ввели информацию о выходном и выходном файле, то все будет записано в calc.txt и calc_out.txt"
end

# Проверка на существование входного файла
if File.exists?(inputFileName)
  # Проверка на существование выходного файла. Если такой не найден, то записываем все в дефолтный.
  unless File.exists?(outputFileName)
    # Если этот файл не является дефолтным, то заменяем его таковым
    if outputFileName != "calc_out.txt"
      puts "Файл с именем #{outputFileName} не найден. Поэтому записываем в calc_out.txt"
      outputFileName = "calc_out.txt"
    end        
  end
  
  # Используется механизм исключени как для работы с файлами, так и для проведения арифметических операций.
  begin
    # Открываем файлы для чтения и записи с соответствующими правами.
    in_f = File.open(inputFileName, 'r')
    out_f = File.open(outputFileName, 'w')
    
    # Построчно считываем файл и производим анализ
    in_f.each_line do |line|
      # Если строка не является пустой
      unless line.chomp.empty?        
        # Ищем в получившейся строке подстроку, которая удовлетворяет регулярному выражению ниже
        match = line.scan(/((?<![.,\w])[+-]?\d+(?![.,\w]))\s?([+\-*\/])\s?((?<![.,\w])[+-]?\d+(?![.,\w]))/)
        # Если найдена только одна подстрока, то производим необходимую операцию
        if match.count == 1
          i, op, j = match[0]
          # Для проведения арифметического действия используется метод #send, передавая ему в качестве аргумента символ, соответствующий имени арифметической операции
          begin
            out_f.write("#{i} #{op} #{j} = #{i.to_i.send op, j.to_i}\n")
          rescue ZeroDivisionError # Деление на ноль
            out_f.write("На ноль делить нельзя\n")
          rescue => e # Здесь ловится всё остальное
            out_f.write("Случилось непредвиденное: #{err}\n")
          end
        elsif match.count == 0  
          out_f.write("Совпадений не найдено в строке: #{line}")
        else
          out_f.write("Строка содержит более 1-ой арифметической операции: #{line}")
        end
      else
        out_f.write("Введена пустая строка\n")
      end       
    end
    
  rescue IOError
  out_f.write("Не удалось записать на диск\n")
  
  rescue SystemCallError
  out_f.write("Произошла ошибка системного вызова\n")
  
  rescue => err # Здесь ловится всё остальное (ошибка при считывании)
    # В случае возникновения ошибки записываем всю информацию в файл и выводим на консоль.
    out_f.write("Внешняя ошибка: #{err}\n")
    err
    
  ensure # Этот блок выполняется в любом случае
    # Вне зависимости от успешности выполнения "небезопасного" блока, файлы будут закрыты
    in_f.close unless in_f.nil?
    out_f.close unless out_f.nil?
  end
else
  puts "Файл с именем #{inputFileName} не найден."
end


# Пример реализации с использованием eval:

#def calc(user_input)
#  result = eval(input_string)
#  puts "Answer: #{result}"
#end
#puts "Enter formula"

#user_input = gets()
# e.g. "1+3*8"

#calc(user_input)